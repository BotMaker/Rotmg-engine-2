puts(1,"start realm of the god engine\n")


include eugl.ew
include winbmp.ew
include misc.e
include database.e
include light.ew


without warning
without type_check


integer keyboard_char
keyboard_char=0

integer zoom_scale
zoom_scale=0


--new modual 
include texture.ew
include spritesheet.ew
include font.ew
include d3d.ew as d3d
include extra.ew as ext

include hash.ew
include objects.ew
include projectile.ew
include projectile_enemy.ew

global integer font0,font1,font2
global integer spr_players
constant lighting_switch = 0


puts(1,"loading xml data\n")
include tinyxml.ew
global atom doc
doc= tinyxml_document()
include "groundxml.ew"
include "equipxml.ew"
include "xmlall.ew"
include "projectilexml.ew"

include button.ew


integer objectlist,hashlist,projectilelist
objectlist=object_new()
hashlist=hash_new()
projectilelist=projectile_new()


include wmap.ew

global sequence walkable,obstacle
walkable={}
obstacle={}






global atom camera_x,camera_y,camera_z,camera_yaw
camera_yaw=90
camera_x=86
camera_y=84
camera_z=21 --values from rotmg changred from 12

global function speed_ground(atom x, atom y)
atom speed_mut
  x=floor(x)
  y=floor(y)

  	
  speed_mut = 1
  if sequence(ground_delta(mapdata[y][x],ground_speed)) then
    speed_mut = real( ground_delta(mapdata[y][x],ground_speed) )
  end if

  return speed_mut 
    
end function



include player.ew
include grid.ew
include enemy.ew

procedure map_load()
  --wmap_load("map.wmap")
  --wmap_load("nexus.wmap")
  wmap_load("world1.wmap")
  obstacle=objectdata

  player_x=floor(map_width/2)
  player_y=floor(map_height/2)
  
  --player_x=1127
  --player_y=1122

  for y=1 to map_height do
    walkable=append(walkable,repeat(1,map_width))
    for x=1 to map_width do
      if objectdata[y][x]>0 then
      if sequence(object_delta(objectdata[y][x],object_OccupySquare)) then
        walkable[y][x]=0
      end if
      end if
    end for
  end for

end procedure


procedure map_load2()
    integer fn,char1,char2,width,height,count,xx,yy,object_handle,object_type


  fn=open("mapdata.txt","rb")
  char1=getc(fn)
  char2=getc(fn)
  width=(char2*256)+char1
  char1=getc(fn)
  char2=getc(fn)
  height=(char2*256)+char1
  
  map_width=width
  map_height=height
  player_x=floor(width/2)
  player_y=floor(height/2)

  for y=1 to height do
    mapdata=append(mapdata,repeat(0,width))
    walkable=append(walkable,repeat(1,width))
	obstacle=append(obstacle,repeat(1,width))
	sizedata=append(sizedata,repeat(1,width))
    for x=1 to width do
      char1=getc(fn)
      char2=getc(fn)
      mapdata[y][x]=(char2*256)+char1
      --if mapdata[y][x]=0 then
       --puts(1,"found\n")
      --end if
    end for
  end for
  close(fn)


  fn=open("mapobjects.txt","rb")
  char1=getc(fn)
  char2=getc(fn)
  count=(char2*256)+char1
  for i=1 to count do
    char1=getc(fn)
    char2=getc(fn)
    object_type=(char2*256)+char1

  	char1=getc(fn)
    char2=getc(fn)
    xx=(char2*256)+char1
    char1=getc(fn)
    char2=getc(fn)
    yy=(char2*256)+char1

	--?xx
	--?yy
	--sleep(1)
	sizedata[yy][xx]=0
	obstacle[yy][xx]=object_type
	if obstacle[yy][xx]>0 then
      if sequence(object_delta(obstacle[yy][xx],object_OccupySquare)) then
        walkable[yy][xx]=0
		
      end if
      end if
  end for
  
  close(fn)
end procedure
--map_load2()

atom ttt
integer facedrawn,count
integer fps
fps=0
ttt=90
facedrawn=0  
count=0

integer mousex,mousey,mouse_button,mouse_button_pressed,mouse_button_clicked
mousex=0
mousey=0
mouse_button=0
mouse_button_pressed=0
mouse_button_clicked=0
integer frames,loop_id
constant VK_END= #23, VK_HOME= #24

atom angle
angle=0


atom xxx,mode
xxx=0
mode=0

sequence object_bitmaps
object_bitmaps={}
 





procedure init()
        integer tex,spr
		
		puts(1,"loading graphics\n")

        --disable vsyps
        if wgl_supportsExtension("WGL_EXT_swap_control") then
		wgl_enableExtension("WGL_EXT_swap_control")
		
                if wgl_swapIntervalEXT(0) then
     		end if
	end if

        d3d_start()

        d3d_set_perspective(1)

        -- Generate texture IDs 
	gl_genTextures(texNum, texID)
	

	-- Load textures 
	tex=texture_load("data\\grass.bmp")
        tex=texture_load("data\\grassd.bmp")
        tex=texture_load("data\\drit.bmp")
        tex=texture_load("data\\tree.bmp")
        tex=texture_load("data\\tree2.bmp")
        tex=texture_load("data\\temp.bmp")
        tex=texture_load("data\\a.bmp")
		

        spr=spritesheet_new(texture_load("data\\lofiEnvironment.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiEnvironment", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\lofiEnvironment2.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiEnvironment2", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\lofiEnvironment3.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiEnvironment3", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})
 
        spr=spritesheet_new(texture_load("data\\lofiObj3.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiObj3", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})


        --new for equipment bitmaps
        spr=spritesheet_new(texture_load("data\\lofiChar8x8.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiChar8x8", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\lofiChar28x8.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiChar28x8", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\lofiObj.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiObj", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\lofiObj2.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiObj2", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\lofiObj4.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiObj4", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\lofiObj5.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiObj5", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\lofiObj6.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiObj6", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\playersSkins.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"playersSkins", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr_players=spritesheet_new(texture_load("data\\players.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"players", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})
 
        
        spr=spritesheet_new(texture_load("data\\lofiObjBig.bmp"),16,16)
        object_bitmaps=append(object_bitmaps,{"lofiObjBig", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\lofiProjs.bmp"),8,8)
        object_bitmaps=append(object_bitmaps,{"lofiProjs", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        --new

        spr=spritesheet_new(texture_load("data\\chars16x16dEncounters.bmp"),16,16)
        object_bitmaps=append(object_bitmaps,{"chars16x16dEncounters", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\chars16x16dEncounters2.bmp"),16,16)
        object_bitmaps=append(object_bitmaps,{"chars16x16dEncounters2", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\chars16x16dMountains1.bmp"),16,16)
        object_bitmaps=append(object_bitmaps,{"chars16x16dMountains1", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\chars16x16dMountains2.bmp"),16,16)
        object_bitmaps=append(object_bitmaps,{"chars16x16dMountains2", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})

        spr=spritesheet_new(texture_load("data\\chars16x16rEncounters.bmp"),16,16)
        object_bitmaps=append(object_bitmaps,{"chars16x16rEncounters", spr,spritesheet_list[spr][4],spritesheet_list[spr][5]})
        tex_light=texture_load("data\\pro.bmp")

        puts(1,"computing graphic lookup tables\n")

        ground_set_sprite(object_bitmaps)

        equip_set_sprite(object_bitmaps)

        object_set_sprite(object_bitmaps)

        projectile_set_sprite(object_bitmaps)

        font0=font_load("font.txt","data\\bitmap2.bmp")
        font1=font_load("font2.txt","data\\font2.bmp")
        font2=font_load("font3.txt","data\\font3.bmp")


        gl_enable (GL_TEXTURE_2D)

        frames = 0
	euglTimerFunc(31,loop_id,0)

        gl_enable (GL_BLEND)
        gl_blendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

        gl_alphaFunc(GL_GREATER,0.5)
        gl_enable ( GL_ALPHA_TEST)
		
		--gl_polygonMode(GL_FRONT_AND_BACK,GL_LINE)
  
        ewShowCursor(1)
		puts(1,"loading map\n")
		map_load()
		
		
		
end procedure



procedure projectile_enemy_update_new()
atom dist,period,theta

atom amplitude,frequency

sequence list,object_list
integer bullet_id,ctype
atom x,y,start_time,angle,elapsed_time,vec,modvec,d,angle2
integer ehandle
atom dx,dy,dist2,ex,ey
integer lifetime,speed

--collision
integer object_type

sequence stats,nearby ,enemy_dielist

 

integer found_solid, stype,light
atom a,b,c

enemy_dielist={}

    list=projectile_enemy_get_list(projectilelist)

    object_list=object_get_list( objectlist )

    for j=1 to length(list) do

      if length(list[j]) then
        x=list[j][projectile_enemy_x]
        y=list[j][projectile_enemy_y]
        angle=list[j][projectile_enemy_angle]
        start_time=list[j][projectile_enemy_start_time]
        bullet_id=list[j][projectile_enemy_bullet_id]
        ctype=list[j][projectile_enemy_type]
		light=list[j][projectile_enemy_light]
		

        angle2=angle
        angle=toRotmgAngle(angle)

        lifetime=real(object_delta(ctype, object_lifetime))
        speed=real(object_delta(ctype, object_speed))

      	elapsed_time=current_time()-start_time
      	if elapsed_time>=lifetime then
		  
      	  projectile_enemy_free(projectilelist,j)
	    else
	
            dist = (elapsed_time / 1000.0) * (speed / 10.0)
            if is_even(bullet_id) then
              period=0
            else
              period=PI
            end if

            if sequence(object_delta(ctype,object_wavy)) then
              theta = angle + (PI * 64) * sin(period + 6 * PI * (elapsed_time / 1000))
              x += dist * cos(theta)
              y += dist * sin(theta)
            elsif sequence(object_delta(ctype,object_parametric)) then

                theta = elapsed_time / lifetime * 2 * PI
                a = sin(theta) --* (ProjectileId % 2 != 0 ? 1 : -1);
                b = sin(theta * 2)-- * (ProjectileId % 4 < 2 ? 1 : -1);
                c = sin(angle)
                d = cos(angle)
                x += (a * d - b * c) * 1
                y += (a * c + b * d) * 1
            else
              x += dist * cos(angle)
              y += dist * sin(angle)
              if sequence(object_delta(ctype,object_amplitude)) then
                --puts(1,"amplitude\n")
                amplitude=real(object_delta(ctype,object_amplitude))
                frequency=real(object_delta(ctype,object_frequency))

                d = amplitude * sin(period + elapsed_time / lifetime * frequency * 2 * PI)
                x += d * cos(angle + PI / 2)
                y += d * sin(angle + PI / 2)

              end if
            end if

          stype=real(object_projectile_delta(ctype, 1,object_projectile_ObjectId))

          if sequence(object_projectile_delta(ctype, 1,object_projectile_size)) then
            draw_spritesheet_floor_angle(x,y, real(object_projectile_delta(ctype, 1,object_projectile_size))/100 , projectile_delta_mod(stype,projectile_sprite), projectile_delta_mod(stype,projectile_indexx),(-angle2-(90+45))+180 )

          else
            draw_spritesheet_floor_angle(x,y, 1, projectile_delta_mod(stype,projectile_sprite), projectile_delta_mod(stype,projectile_indexx),(-angle2-(90+45))+180 )
          end if
		  
		  
		  
          dx = x - player_x
          dy = y - player_y
          dist2 = dx*dx + dy*dy

          if dist2 < 1 then  
                  
            player_health-=10
            -- optional: mark projectile for deletion
            projectile_enemy_free(projectile_enemy_list, j)
		  
		  end if
		  
			
          
          if walkable[floor(y)][floor(x)]=0  then
            projectile_enemy_free(projectile_enemy_list, j)
          end if

      	end if

      end if	


    end for


end procedure






procedure projectile_update_new()
atom dist,period,theta

atom amplitude,frequency

sequence list,object_list
integer bullet_id,ctype
atom x,y,start_time,angle,elapsed_time,vec,modvec,d,angle2
integer ehandle
atom dx,dy,dist2,ex,ey
integer lifetime,speed

--collision
integer object_type

sequence stats,nearby ,enemy_dielist

 

integer found_solid, stype,light
atom a,b,c

enemy_dielist={}

    list=projectile_get_list(projectilelist)

    object_list=object_get_list( objectlist )

    for j=1 to length(list) do

      if length(list[j]) then
        x=list[j][projectile_x]
        y=list[j][projectile_y]
        angle=list[j][projectile_angle]
        start_time=list[j][projectile_start_time]
        bullet_id=list[j][projectile_bullet_id]
        ctype=list[j][projectile_type]
		light=list[j][projectile_light]
		
		
		

        angle2=angle
        angle=toRotmgAngle(angle)

        lifetime=real(object_delta(ctype, object_lifetime))
        speed=real(object_delta(ctype, object_speed))

      	elapsed_time=current_time()-start_time
      	if elapsed_time>=lifetime then
		  light_delete(light)
      	  projectile_free(projectilelist,j)
	    else
	
            dist = (elapsed_time / 1000.0) * (speed / 10.0)
            if is_even(bullet_id) then
              period=0
            else
              period=PI
            end if

            if sequence(object_delta(ctype,object_wavy)) then
              theta = angle + (PI * 64) * sin(period + 6 * PI * (elapsed_time / 1000))
              x += dist * cos(theta)
              y += dist * sin(theta)
            elsif sequence(object_delta(ctype,object_parametric)) then

                theta = elapsed_time / lifetime * 2 * PI
                a = sin(theta) --* (ProjectileId % 2 != 0 ? 1 : -1);
                b = sin(theta * 2)-- * (ProjectileId % 4 < 2 ? 1 : -1);
                c = sin(angle)
                d = cos(angle)
                x += (a * d - b * c) * 1
                y += (a * c + b * d) * 1
            else
              x += dist * cos(angle)
              y += dist * sin(angle)
              if sequence(object_delta(ctype,object_amplitude)) then
                --puts(1,"amplitude\n")
                amplitude=real(object_delta(ctype,object_amplitude))
                frequency=real(object_delta(ctype,object_frequency))

                d = amplitude * sin(period + elapsed_time / lifetime * frequency * 2 * PI)
                x += d * cos(angle + PI / 2)
                y += d * sin(angle + PI / 2)

              end if
            end if

          stype=real(object_projectile_delta(ctype, 1,object_projectile_ObjectId))

          if sequence(object_projectile_delta(ctype, 1,object_projectile_size)) then
            --?
            draw_spritesheet_floor_angle(x,y, real(object_projectile_delta(ctype, 1,object_projectile_size))/100 , projectile_delta_mod(stype,projectile_sprite), projectile_delta_mod(stype,projectile_indexx),(-angle2-(90+45))+180 )

          else
            draw_spritesheet_floor_angle(x,y, 1, projectile_delta_mod(stype,projectile_sprite), projectile_delta_mod(stype,projectile_indexx),(-angle2-(90+45))+180 )
          end if
		  
		  light_set_x(light,x)
          light_set_y(light,y)
		  
		  nearby = grid_get_nearby(x, y, 1)
			
	      if length(nearby) then
            for k = 1 to length(nearby) do
              ehandle = nearby[k][1]
              if length(enemy_list[ehandle]) > 0 then
                ex = enemy_list[ehandle][ENEMY_X]
                ey = enemy_list[ehandle][ENEMY_Y]

                -- simple distance-based collision
                dx = x - ex
                dy = y - ey
                dist2 = dx*dx + dy*dy

                if dist2 < 1 then  
                  -- Hit enemy
                  enemy_list[ehandle][ENEMY_HEALTH] -= 10  -- example damage
				
				  if enemy_list[ehandle][ENEMY_HEALTH] <0 then
				     enemy_dielist&=ehandle
				  end if

                -- optional: mark projectile for deletion
                light_delete(light)
                projectile_free(projectilelist, j)
               end if
             end if
           end for
         end if	
          
          if walkable[floor(y)][floor(x)]=0  then
		    light_delete(light)
            projectile_free(projectilelist,j)
  
          end if

      	end if

      end if	

      for h=1 to length(enemy_dielist) do
        enemy_delete(enemy_dielist[h])
      end for

    end for


end procedure

  

procedure draw_description_text(integer x, integer y ,sequence text)
  sequence lines
  integer pos,count
  pos=1
  count=0
  lines={}

  for i=1 to length(text) do
    if text[i]='_' then
      text[i]=' '
    end if
  end for

  for i=1 to length(text) do
    count+=1
    if count=30 then --char limt per line
      lines=append(lines,text[pos..i])
      pos=i+1
      count=0
    elsif i=length(text) then
      lines=append(lines,text[pos..i])
      pos=i+1
      count=0
    end if
  end for

  for i=1 to length(lines) do
    draw_text(x,y,lines[i])
    y+=20
  end for
  
end procedure


sequence inv_slot_buttons
inv_slot_buttons={}

procedure gui_inv_slots_create()
  integer x ,y,startx,starty,index,tmp
  
  startx=610
  starty=370-40

  x=0
  y=0
  
  for i=1 to 12 do
  
    if inv[i][1]!=-1 then
	  index=inv[i][1]
	  inv_slot_buttons&=button_new( startx+x, starty+ y, 40, 40,index,i)
	else
	  inv_slot_buttons&=button_new( startx+x, starty+ y, 40, 40,-1,-1)
    end if

	x+=44
	 
    if i=4 or i=8 then
      y+=44
      x=0
    end if
	  
	
  end for
end procedure 

 gui_inv_slots_create()


procedure gui_draw_inv_slots2()
  integer x ,y,index,item,slot,startx,starty
  
  --610
  --370
  startx=610
  starty=370-40

  x=0
  y=0

  currentfont=font0

  draw_set_color(179,179,179)
  draw_text(620, 300,"SPD-"&sprint(speed_stat))

  draw_set_color(179,179,179)
  draw_text(720, 300,"DEX-"&sprint(dex_stat))

  
  for i=1 to 12 do

    draw_set_color(84,84, 84)
    draw_rectangle(startx+x,starty+y, startx+40+x,starty+40+y, 0)
    
    currentfont=font2
    draw_set_color(54,54,54)

    if inv[i][1]=-1 or selected=i and i>4 then
      draw_text(startx+x+8,starty+y,sprint(i-4))
    end if
	
	x+=44

    if i=4 or i=8 then
      y+=44
      x=0
    end if

  end for
  
   button_draw()

  
end procedure


procedure mark_walkable()
  sequence object_list
  integer object_type
  atom x,y

  object_list=object_get_list( objectlist )
 
  for k=1 to length(object_list) do
    if length(object_list[k]) then

     object_type=object_get_type(objectlist,k)
     x=object_get_x(objectlist,k)
     y=object_get_y(objectlist,k)
     --puts(1,object_delta(object_type,object_file)&"\n" )
     if sequence(object_delta(object_type,object_OccupySquare)) then
       walkable[floor(y)][floor(x)]=0
       
     end if
    end if
  end for

end procedure

 sequence lights
lights = {
    {1024+20, 1024+15, 1.0, 0.6, 0.2, 1.0, 0.5},   -- warm torch (orange)
    {1024+35, 1024+18, 0.3, 0.5, 1.0, 0.8, 0.5},    -- cool magic glow (blue)
    {1024+50, 1024+10, 1.0, 1.0, 1.0, 0.7, 1}     -- white lamp
}

integer light1,light2,light3

--light1=light_new(1024+20, 1024+15, 1.0, 0.6, 0.2, 1.0, 10)
--light2=light_new(1024+35, 1024+18, 0.3, 0.5, 1.0, 0.8, 8)
--light3=light_new(1024+50, 1024+10, 1.0, 1.0, 1.0, 0.7, 6)


light1=light_new(1024+20, 1024+15, 1.0, 0.6, 0.2, 1.0, 10)
light2=light_new(1024+25, 1024+18, 0.3, 0.5, 1.0, 0.8, 8)
light3=light_new(1024+30, 1024+21, 1.0, 1.0, 1.0, 0.7, 6)

global function get_brightness(atom x, atom y, atom posx,atom posy)
atom dx,dy,dist2,brightness
                -- Distance squared from player
                dx = x- posx
                dy = y- posy
                dist2 = dx*dx + dy*dy

                -- Use inverse falloff without sqrt
                -- Tweak divisor to control light radius (e.g. 64 = 8^2)
                brightness = 1 - (dist2 / (128 + zoom_scale*zoom_scale))

                -- Clamp brightness between 0.4 and 1.0
                if brightness < 0.4 then
                    brightness = 0.4
                elsif brightness > 1.0 then
                    brightness = 1.0
                end if
	return brightness		
end function

global function get_brightness_render(atom x, atom y, atom posx,atom posy)
atom dx,dy,dist2,brightness
                -- Distance squared from player
                dx = x- posx
                dy = y- posy
                dist2 = dx*dx + dy*dy

                -- Use inverse falloff without sqrt
                -- Tweak divisor to control light radius (e.g. 64 = 8^2)
                brightness = 1 - (dist2 / (128 + zoom_scale*zoom_scale))

                -- Clamp brightness between 0.4 and 1.0
                if brightness < 0.2 then
                    brightness = 0.2
                elsif brightness > 1.0 then
                    brightness = 1.0
                end if
	return brightness		
end function


procedure render()
  integer mult,object_type
  atom v,brightness,last_brightness
  last_brightness=-1

  v=0
    gl_texEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE)
    for y=floor(camera_y)-(12+zoom_scale) to floor(camera_y)+(8+zoom_scale) do
      for x=floor(camera_x)-(14+zoom_scale) to floor(camera_x)+(6+zoom_scale) do
         if lighting_switch=1 then
           brightness=get_brightness_render(x,y,player_x,player_y)
		   
		   if ext:abs(brightness - last_brightness) > 0.05 then
             gl_color4f({brightness, brightness, brightness, 0})
             last_brightness = brightness
           end if
          
		   
	       gl_color4f({brightness, brightness, brightness, 1})
		end if
	  
	  --gl_color4f({0, 0, 0, 0}	  
      object_type=obstacle[y][x]

      if  object_type>0 and x>0 and y>0 and x<map_width and y<map_height then
      mult=1

      if sequence(object_delta(object_type, object_animated)) then
        mult=7
      end if

      if sequence(object_delta(object_type, object_size)) then

       if object_delta_mod(object_type,object_sprite)!=0 then
        if sizedata[y][x]!=0 then
		  d3d_bind_texture(spritesheet_list[object_delta_mod(object_type,object_sprite)][spritesheet_texture])
          draw_spritesheet_tile6(x,y,  sizedata[y][x]/100, object_delta_mod(object_type,object_sprite), mult*object_delta_mod(object_type,object_indexx) ,v )
        else
		  
		  d3d_bind_texture(spritesheet_list[object_delta_mod(object_type,object_sprite)][spritesheet_texture])
          draw_spritesheet_tile6(x,y,  real(object_delta(object_type, object_size))/100, object_delta_mod(object_type,object_sprite), mult*object_delta_mod(object_type,object_indexx),v )
        end if
       end if

      else
        if object_delta_mod(object_type,object_sprite)!=0 then
          
        if sizedata[y][x]!=0 then
		  d3d_bind_texture(spritesheet_list[object_delta_mod(object_type,object_sprite)][spritesheet_texture])
          draw_spritesheet_tile6(x,y,  sizedata[y][x]/100, object_delta_mod(object_type,object_sprite), mult*object_delta_mod(object_type,object_indexx),v )
        else
		 d3d_bind_texture(spritesheet_list[object_delta_mod(object_type,object_sprite)][spritesheet_texture])
         draw_spritesheet_tile2(x,y, object_delta_mod(object_type,object_sprite), mult*object_delta_mod(object_type,object_indexx),v )
        end if
          
        end if
      end if

      v+=0.001
      end if
      
    end for
  end for


gl_color4f({1,1,1, 1})

 
end procedure




 --Lerp function to interpolate between two values global 
 function lerp(atom a, atom b, atom t) 
   return a + (b - a) * t 
 end function

-- Function to get health percentage (0.0 to 1.0) global 
function get_health_percent() 
  return player_health / max_health 
end function



procedure draw_health()
-- Add health bar rendering
atom health_percent
atom bar_width
atom green 
atom red 

health_percent = get_health_percent()
bar_width = 150 * health_percent
green = lerp(0.0, 1.0, health_percent)  -- Green component (0 to 1)
red = lerp(1.0, 0.0, health_percent)    -- Red component (1 to 0)

draw_set_color(128, 128, 128)  -- Gray border
draw_rectangle(615, 5, 775, 35, 0)  -- Border rectangle (slightly larger)


draw_set_color(0, 0, 0)  -- Black background
draw_rectangle(620, 10, 770, 30, 0)  -- Background rectangle (150 pixels wide)

draw_set_color(floor(red * 255), floor(green * 255), 0)  -- Interpolated color
draw_rectangle(620, 10, 620 + floor(bar_width), 30, 0)  -- Filled portion

currentfont = font0
draw_set_color(255, 255, 255)
draw_text(620, 12, sprintf("Health: %.0f/%.0f", {player_health, max_health}))


end procedure



atom debug_time
debug_time = current_time()+100

sequence input_string
input_string=""

integer input_onoff
input_onoff=0


atom light_dir,light_speed,light_change_time
atom start_x,start_y
light_dir=0
light_speed=10
light_change_time=current_time()+1

start_x=light_get_x(light1)
start_y=light_get_y(light1)

constant TARGET_FRAME_MS = 8   

constant SCREEN_W = 800
constant SCREEN_H = 600
constant TILES_VISIBLE_X = 21
constant TILES_VISIBLE_Y = 21

constant TILE_SIZE_X = SCREEN_W / TILES_VISIBLE_X
constant TILE_SIZE_Y = SCREEN_H / TILES_VISIBLE_Y

global function world_to_screen3(atom world_x, atom world_y)
    atom screen_x, screen_y

    -- Convert tile coordinate to pixel coordinate
    screen_x = (world_x - camera_x) * TILE_SIZE_X
    screen_y = (world_y - camera_y) * TILE_SIZE_Y
	
	screen_x = (world_x - camera_x) * TILE_SIZE_X + (SCREEN_W / 2)
    screen_y = (world_y - camera_y) * TILE_SIZE_Y + (SCREEN_H / 2)

    return {screen_x, screen_y}
end function


function world_to_screen4(atom world_x, atom world_y)
    atom screen_x, screen_y

    -- Center-based camera: subtract camera, scale by tile size,
    -- then shift to center of screen and align to tile center.
    screen_x = (world_x - camera_x) * TILE_SIZE_X + (SCREEN_W / 2) - (TILE_SIZE_X / 2)
    screen_y = (world_y - camera_y) * TILE_SIZE_Y + (SCREEN_H / 2) - (TILE_SIZE_Y / 2)

    -- Optional: snap to integer pixel positions
    screen_x = floor(screen_x)
    screen_y = floor(screen_y)

    return {screen_x, screen_y}
end function





procedure draw_dist()
sequence nearby ,pos
integer ehandle,count
atom ex,ey,dx,dy,dist2,xx,yy,dir, enemy_x,enemy_y





   nearby = grid_get_nearby(player_x, player_y, 4)
   if length(nearby) then
      for k = 1 to length(nearby) do
          ehandle = nearby[k][1]
          if length(enemy_list[ehandle]) > 0 then
             ex = enemy_list[ehandle][ENEMY_X]
             ey = enemy_list[ehandle][ENEMY_Y]

             -- simple distance-based collision
             dx = player_x - ex
             dy = player_y - ey
             dist2 = dx*dx + dy*dy
			 
			 --draw_text(100,100,"enemy distance to player "&sprint(dist2))
			 
			 dist2=point_distance(player_x,player_y,ex,ey)
			 --d3d:draw_line(floor(camera_x)-(14+zoom_scale),floor(camera_y)-(12+zoom_scale),ex,ey)
			 d3d:draw_line(  floor(camera_x)-(14+zoom_scale),  floor(camera_y)-(12+zoom_scale)  ,   400,  600)
			 
			 dir=degtorad(get_angle_to(player_x ,  player_y , ex,ey))-90
			 xx=floor(camera_x)-(1+zoom_scale)-player_x+329
			 yy=floor(camera_y)-(zoom_scale)-player_y +300
			 enemy_x=ex  --(floor(camera_x)-(1+zoom_scale))
			 enemy_y=ey  --(floor(camera_y)-(zoom_scale))
			 
			 
			 gl_matrixMode(GL_PROJECTION)
gl_loadIdentity()
glu_perspective(45, 800.0/600, 1, 32000)

gl_matrixMode(GL_MODELVIEW)
gl_loadIdentity()
glu_lookAt({camera_x, camera_y, camera_z},
           {camera_x + cos(camera_yaw*PI/180),
            camera_y + sin(camera_yaw*PI/180),
            0},
           {0, 0, 1})
			 
			  pos =glu_project(enemy_x, enemy_y, 1)
			  pos[2]+=64
			  --?enemy_x
			  --?enemy_y
			  
			 --?pos
			 d3d_set_projection_ortho(0,0,800,600,0)
             d3d_set_hidden(0)
			 --usleep(100)
			 d3d:draw_line(  xx,  yy ,  pos[1], pos[2])

			 --exit
			end if
		end for
	end if
	pos=world_to_screen3(camera_x, camera_y)
	--draw_text( 100,180, "camera postion  "&sprint(camera_x)&"    "&sprint(camera_y) )
	--draw_text( 100,200, "camera postion world" &sprint(pos[1])&"    "&sprint(pos[2]) )
end procedure



 		  

procedure draw()
sequence ppp
atom frametime,deltatime ,brightness,last_brightness,dx,dy,dz
integer index,sprite
atom ex,ey,fx,fy
sequence color
camera_x=player_x+2
camera_y=player_y+1

last_brightness = -1

d3d_set_count(0)

     -- Store time for next frame
    frametime = current_time()
	
	
	
    gl_clear(GL_COLOR_BUFFER_BIT + GL_DEPTH_BUFFER_BIT)

--normal projection
    d3d_set_projection(camera_x,camera_y,camera_z, camera_x+cos(camera_yaw*PI/180), camera_y-sin(camera_yaw*PI/180), 0, 0,0,1)
	
	

gl_enable(GL_TEXTURE_2D)
gl_enable(GL_BLEND)
gl_blendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
gl_texEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE)  -- <-- critical
d3d_bind_texture(1)                           -- your map/tiles spritesheet
gl_color4f({1, 1,1, 1})
	
	
    for y=floor(camera_y)-(12+zoom_scale) to floor(camera_y)+(8+zoom_scale) do
      for x=floor(camera_x)-(14+zoom_scale) to floor(camera_x)+(6+zoom_scale) do
         if x>0 and y>0 and x<map_width and y<map_height then
         index=mapdata[y][x]
         
         if index>0 then
		 
		   if lighting_switch=1 then
		   brightness=get_brightness(x,y,player_x,player_y)
		   
		   if ext:abs(brightness - last_brightness) > 0.05 then
             gl_color4f({brightness, brightness, brightness, 1})
             last_brightness = brightness
           end if
          
		   gl_color4f({brightness, brightness, brightness, 1})
		   end if
           draw_spritesheet_tile(x,y,sprdata[y][x], framedata[y][x])
		   
         end if
         end if
      end for
    end for


   render()
   gl_disable(GL_DEPTH_TEST)
   gl_enable(GL_TEXTURE_2D)
   gl_enable(GL_BLEND)
   gl_blendFunc(GL_SRC_ALPHA, GL_ONE)
   gl_texEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE)
   d3d_bind_texture(tex_light)          -- your light_circle.png
   
   if lighting_switch=1 then
   light_draw2(camera_x, camera_y)
   end if
   gl_disable(GL_BLEND)
   gl_enable(GL_DEPTH_TEST)
   gl_blendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
   gl_texEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE)
   gl_enable(GL_DEPTH_TEST)
   d3d_bind_texture(1) 
   gl_color4f({1, 1, 1, 1})
  

  gl_bindTexture (GL_TEXTURE_2D, 7)



  player_draw()
  --player_name_draw()
  projectile_update_new() 
   projectile_enemy_update_new()

  
  for i = 1 to length(enemy_list) do
        if length(enemy_list[i]) then
             ex = enemy_list[i][ENEMY_X]
             ey = enemy_list[i][ENEMY_Y]
             sprite = enemy_list[i][ENEMY_SPRITE]
            draw_spritesheet_floor(ex, ey, 1, sprite,enemy_list[i][ ENEMY_FRAMEINDEX])  -- Adjust sprite index as needed
        end if
    end for
	
	





  d3d_set_projection_ortho(0,0,800,600,0)
  d3d_set_hidden(0)
  draw_set_color(128,128,128)
  --d3d:draw_line(0,0,100,100)

  draw_set_color(54,54,54)
  draw_rectangle(600,0,800,600,0)


  gui_draw_inv_slots2()
   draw_health()
   
   
   
   currentfont=font0
  draw_set_color(255,0,0)
  

   
   
   
   if current_time()>debug_time then
     grid_debug_summary_full()
	 enemy_debug_count()
	 debug_time=current_time()+100
   end if

   grid_debug_summary_draw()
   enemy_debug_draw()
   draw_dist()

  currentfont=font0
  draw_set_color(255,0,0)
  --draw_text(0,0,"suck on it")
  currentfont=font1
  draw_set_color(0,255,0)
  --draw_text(0,40,"abcdefghijklmnopqurstuvwxyz")



  if keyboard_char!=0 then
    if keyboard_char=13 then 
      input_onoff=not(input_onoff)
      keyboard_char=0
      if input_onoff=0 then--execute commands
        for i=5 to 12 do --inv space
         if inv[i][1]=-1 then
           inv[i][1]=object_type_from_name(input_string)
           exit
         end if
        end for
      end if
      
      input_string=""
    end if
    
  end if

if input_onoff=1 then

  if keyboard_char!=0 then
    if keyboard_char>='A' and keyboard_char<='Z' then    
     input_string&=keyboard_char+26+6
    end if
    if keyboard_char=32 then 
      input_string&=keyboard_char
    end if
    if keyboard_char=8 then
      if length(input_string) then
        input_string=input_string[1..length(input_string)-1]
      end if
    end if
    keyboard_char=0
  end if

  draw_set_color(54,54,54)
  draw_rectangle(0,580,600,600,0)
  currentfont=font1
  draw_set_color(255,255,255)
  draw_text(0,600-20,input_string)
end if
 
  
  d3d_set_hidden(1)

    if ewSwapBuffers(glhDC) then   
    end if

    frames += 1

    deltatime=current_time()-frametime

    -- Sleep if the frame was too fast
    if deltatime < TARGET_FRAME_MS then
      --usleep((TARGET_FRAME_MS - floor(deltatime)) )  -- convert ms → µs
    end if

  
end procedure

atom start_time
start_time=time()+1


integer yyy
yyy=0

atom frametime,deltatime
frametime =current_time()



function rate_of_fire(integer ctype)
atom rate
  rate= (0.0015 + ((dex_stat / 75) * (0.008 - 0.0015)))
  if sequence(object_delta(ctype,object_rateoffire)) then
    return ((1 / rate) * (1 / real(object_delta(ctype,object_rateoffire))))
  end if
  return ((1 / rate))
end function

atom shoot_time
shoot_time=0


integer bullet_id
bullet_id=0

procedure shoot()
integer numofshoot,arcgap,ret
atom x,y

  shooting=1
  if sequence(object_delta(inv[1][1], object_numprojectiles)) then
    numofshoot=real(object_delta(inv[1][1], object_numprojectiles))
  else
    numofshoot=1
  end if
  
  if sequence(object_delta(inv[1][1], object_arcgap)) then
    arcgap=real(object_delta(inv[1][1], object_arcgap))
  else
    arcgap=0
  end if


  for i=1 to numofshoot do
     ret=projectile_enter(projectilelist,player_x,player_y, get_angle_to(300,300,mousex,mousey)+(arcgap * i), current_time() ,bullet_id, inv[1][1], light_new( player_x, player_y, 1.0, 0.8, 0.6, 1.0, 1) )
     bullet_id+=1   
  end for
  
end procedure 


integer player_class
player_class=1

procedure loop(integer timerID)
integer ret
deltatime=current_time()-frametime
frametime =current_time()
 
  shooting=0
  yyy+=1
  if start_time<time() then
    fps=frames
    frames = 0
    start_time=time()+1
    --?time()
    --?yyy
    yyy=0
     euglSetWindowTitle( sprintf("%d fps.",fps)&sprintf(" %f ",camera_x)&sprintf(" %f ",camera_y)&sprintf(" %f ",camera_z)&sprintf(" %d ", d3d_get_count())&sprintf(" %d ",mousex)&sprintf(" %d ",mousey) &sprintf(" %d ", light_get_totalnumber()))
  
  end if

  --ttt+=10
--?ttt

 if mode=0 then
  xxx+=0.1
  angle+=6
else
  xxx-=0.1
  angle+=6
  end if
  if xxx>4 then
    mode=1
  elsif xxx<0 then
   mode=0
  end if
  
  if key_check(VK_LEFT) then 
    camera_yaw+=4

  end if
    
  if key_check(VK_RIGHT) then 
    camera_yaw-=4

  end if
  
  if key_check('A') then 
    camera_x = camera_x + (cos (degtorad(camera_yaw+90)) * .5)
    camera_y = camera_y + -(sin (degtorad(camera_yaw+90)) * .5)
  end if
    
  if key_check('D') then 
    
    camera_x = camera_x + (cos (degtorad(camera_yaw-90)) * .5)
    camera_y = camera_y + -(sin (degtorad(camera_yaw-90)) * .5)
  end if

  if key_check('W')  then
    camera_x = camera_x + (cos (degtorad(camera_yaw)) * .5)
    camera_y = camera_y + -(sin (degtorad(camera_yaw)) * .5)
  end if

  if key_check('S')  then
    camera_x = camera_x + (cos (degtorad(camera_yaw-180)) * .5)
    camera_y = camera_y + -(sin (degtorad(camera_yaw-180)) * .5)
  end if


  if key_check(VK_END)  then
    camera_z+=1
  end if

  if key_check(VK_HOME)  then
    camera_z-=1
	
  end if
  
  if key_check(' ')  then
	
	
	--ret=enemy_new(1020, 1020, 100.0, 0.1, 5) 
    --ret=enemy_new(1021, 1021, 100.0, 0.1, 5) 
	--ret=enemy_new(1022, 1022, 100.0, 0.1, 5) 
	--ret=enemy_new(1023, 1023, 100.0, 0.1, 5) 
	
  end if
  
  
  
  if key_check('Z')  then
	zoom_scale+=1
  end if

  if key_check('X')  then
	zoom_scale-=1
  end if

  if mouse_button=1 and selected=0 and inv[1][1]>0 then 
    shooting=1
    if shoot_time<current_time() then
      shoot_time=current_time()+rate_of_fire(inv[1][1])
      shoot()
      
      --?get_angle_to(300,300,mousex,mousey)
    end if
  end if

  if input_onoff=0 then
    player_update()
  end if
  
  -- Update all enemies
    for i = 1 to length(enemy_list) do
        if length(enemy_list[i]) then
            enemy_update(i)
        end if
    end for  

  euglTimerFunc(30,loop_id,0)
end procedure
loop_id = routine_id("loop")



procedure key(integer keycode,integer mode,integer y)
integer ret
 	if keycode = VK_ESCAPE then
  	  ewPostQuitMessage(#10)
          abort(0)
  	end if

        if mode=0 then
          keyboard_char=keycode
          key_add(keycode)
		    if key_check(' ')  then

	         --ret=enemy_new(1020, 1020, 100.0, 0.1, 5) 
		     ret=enemy_new(camera_x, camera_y, 100.0, 0.1, 5) 
           end if
        else
         key_remove(keycode)
        end if

end procedure

procedure mouse(integer event,integer v1,integer v2,integer v3)
  if event=EUGL_LEFT_BUTTON and v1=EUGL_DOWN then
    --puts(1,"left mouse down\n")
    mouse_button=1
	mouse_button_pressed=1
	mouse_button_clicked=1
	button_mouse_pressed(mousex,mousey)

  elsif event=EUGL_LEFT_BUTTON and v1=EUGL_UP then
    --puts(1,"left mouse up\n")
    mouse_button=2
	mouse_button_pressed=0
	button_mouse_released(mousex,mousey)
  end if
end procedure



procedure motion(integer x,integer y)
  mousex=x
  mousey=y
  button_update_mouse(x,y)
  --?mousex
  --?mousey
  --usleep( 30)
end procedure


procedure reshape(integer w,integer h)
	--gl_viewport(0,0,w,h)
end procedure


-- Tell EuGL to use double-buffering
euglFlags = PFD_DOUBLEBUFFER	

-- If you want fullscreen, uncomment the next two lines.
-- euglPFD[EUGL_COLORBITS] = 16
-- euglDisplayMode = EUGL_FULLSCREEN	

euglDisplayFunc(routine_id("draw"))
euglInitFunc(routine_id("init"))
euglReshapeFunc(routine_id("reshape"))
euglKeyboardFunc(routine_id("key"))
euglMouseFunc( routine_id("mouse") )
euglPassiveMotionFunc( routine_id("motion") )

EuGLMain(EUGL_HANDLE_EVENTS, "open world engine", 800+10, 600+30)