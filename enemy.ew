include projectile_enemy.ew



-- Global data
--global sequence enemy_list
sequence class_freelist, enemy_freelist
global integer projectile_enemy_list
enemy_list = {}
class_freelist = {}
enemy_freelist = {}
projectile_enemy_list = projectile_enemy_new()

global procedure enemy_init()
  enemy_list = {}
  class_freelist = {}
  enemy_freelist = {}
  
end procedure


integer active, free_count, total
    active = 0
    total = 0
    free_count = 0

global procedure enemy_debug_count()
    active = 0
    total = 0
    free_count = 0
    total = length(enemy_list)
    free_count = length(enemy_freelist)

    for i = 1 to total do
        if length(enemy_list[i]) then
            active += 1
        end if
    end for


end procedure

global procedure enemy_debug_draw()

    
    draw_text(0,140,"=== Enemy Count Debug === ")
	draw_text(0,160,"Total Handles: "&sprint(total))
	draw_text(0,180,"Active Enemies: "&sprint(active))
	draw_text(0,200,"Free Handles: "&sprint(free_count))

end procedure

global function enemy_new(atom x, atom y, atom health, atom speed, integer sprite,integer frame)
    integer handle
    if length(enemy_freelist) > 0 then
        handle = enemy_freelist[1]
        enemy_freelist = enemy_freelist[2..length(enemy_freelist)]
    else
        enemy_list = append(enemy_list, {})
        handle = length(enemy_list)
    end if

    enemy_list[handle] = {
        x,                      -- ENEMY_X
        y,                      -- ENEMY_Y
        health,                 -- ENEMY_HEALTH
        speed,                  -- ENEMY_SPEED
        0,                      -- ENEMY_STATE
        0, 0,                   -- ENEMY_TARGET_X, ENEMY_TARGET_Y
        sprite,                 -- ENEMY_SPRITE
        frame,              -- ENEMY_FRAMEINDEX
        grid_new(x, y, handle), -- ENEMY_GRID_HANDLE
        current_time() + 1000,  -- ENEMY_NEXT_SHOT
        1500,                   -- ENEMY_SHOOT_INTERVAL (1.5 sec)
        8,                  -- ENEMY_SHOOT_RANGE
        x,                      -- ENEMY_START_X
        y                       -- ENEMY_START_Y
		
    }

    return handle
end function




-- Function to get enemy properties
global function enemy_get_x(integer handle)
    return enemy_list[handle][ENEMY_X]
end function

global function enemy_get_y(integer handle)
    return enemy_list[handle][ENEMY_Y]
end function

global function enemy_get_state(integer handle)
    return enemy_list[handle][ENEMY_STATE]
end function

global procedure enemy_set_x(integer handle, atom x)
    enemy_list[handle][ENEMY_X] = x
end procedure

global procedure enemy_set_y(integer handle, atom y)
    enemy_list[handle][ENEMY_Y] = y
end procedure

global procedure enemy_delete(integer handle)
    integer grid_handle
	
	if handle < 1 or handle > length(enemy_list) then 
      puts(1,"enemy_delete error\n")
      return 
    end if
	if length( enemy_list[handle]) then
	grid_handle = enemy_list[handle][ENEMY_GRID_HANDLE]
    empty_delete(grid_handle)
	
    enemy_list[handle] = {}
    enemy_freelist = append(enemy_freelist, handle)
	end if
end procedure

-----------------------------------------------------
-- Enemy Shooting Logic
-----------------------------------------------------
integer bullet_id
bullet_id = 0

global procedure enemy_shoot(integer handle)
    integer numofshoot, arcgap, ret, item
    atom x, y

    item = #910
    x = enemy_list[handle][ENEMY_X]
    y = enemy_list[handle][ENEMY_Y]

    if sequence(object_delta(item, object_numprojectiles)) then
        numofshoot = real(object_delta(item, object_numprojectiles))
    else
        numofshoot = 1
    end if

    if sequence(object_delta(item, object_arcgap)) then
        arcgap = real(object_delta(item, object_arcgap))
    else
        arcgap = 0
    end if

    for i = 1 to numofshoot do
        ret = projectile_enemy_enter(
            projectile_enemy_list,
            x, y,
            get_angle_to(x, y, player_x, player_y) + (arcgap * i),
            current_time(),
            bullet_id,
            item,
            -1
        )
        bullet_id += 1
    end for
end procedure

-----------------------------------------------------
-- Enemy Update Logic
-----------------------------------------------------
constant WANDER_RADIUS = 50.0
constant WANDER_LIMIT  = 100.0  -- max distance from start position
constant CHASE_RANGE   = 10.0
constant FLEE_RANGE    = 50.0
constant FLEE_THRESHOLD = 50.0

global procedure enemy_update(integer handle)
    atom dx, dy, dist, angle, move_x, move_y, now
    integer state, grid_handle
    atom health_percent
    atom startx, starty

    if not length(enemy_list[handle]) then
        return
    end if

    state = enemy_list[handle][ENEMY_STATE]
    health_percent = enemy_list[handle][ENEMY_HEALTH] / 100.0
    grid_handle = enemy_list[handle][ENEMY_GRID_HANDLE]
    now = current_time()

    startx = enemy_list[handle][ENEMY_START_X]
    starty = enemy_list[handle][ENEMY_START_Y]

    -- Calculate distance to player
    dx = player_x - enemy_list[handle][ENEMY_X]
    dy = player_y - enemy_list[handle][ENEMY_Y]
    dist = sqrt(dx * dx + dy * dy)

    -- Behavior transitions
    if (health_percent <= FLEE_THRESHOLD / 100.0) or (state = 2 and dist < FLEE_RANGE) then
        if (state = 2 and dist < FLEE_RANGE) then
            state = 2
        else
            state = 0
        end if
    elsif dist < CHASE_RANGE then
        state = 1
    else
        state = 0
    end if
    enemy_list[handle][ENEMY_STATE] = state

    -- Movement
    if state = 0 then  -- Wander
        -- occasionally pick a new random target within WANDER_RADIUS
        if rand(100) < 10 then
            angle = rand(360) * PI / 180.0
            enemy_list[handle][ENEMY_TARGET_X] = startx + cos(angle) * WANDER_RADIUS
            enemy_list[handle][ENEMY_TARGET_Y] = starty + sin(angle) * WANDER_RADIUS
        end if

        -- Check if enemy is too far from start position
        dx = enemy_list[handle][ENEMY_X] - startx
        dy = enemy_list[handle][ENEMY_Y] - starty
        dist = sqrt(dx * dx + dy * dy)
        if dist > WANDER_LIMIT then
            -- move back toward start position if too far away
            enemy_list[handle][ENEMY_TARGET_X] = startx
            enemy_list[handle][ENEMY_TARGET_Y] = starty
        end if
		
		dx = enemy_list[handle][ENEMY_X] - player_x
        dy = enemy_list[handle][ENEMY_Y] - player_y
        dist = sqrt(dx * dx + dy * dy)
		
		-- ðŸ”« Shooting check
        if dist <= enemy_list[handle][ENEMY_SHOOT_RANGE] then
            if now >= enemy_list[handle][ENEMY_NEXT_SHOT] then
                enemy_shoot(handle)
                enemy_list[handle][ENEMY_NEXT_SHOT] = now + enemy_list[handle][ENEMY_SHOOT_INTERVAL]
            end if
        end if

        -- Move toward target
        dx = enemy_list[handle][ENEMY_TARGET_X] - enemy_list[handle][ENEMY_X]
        dy = enemy_list[handle][ENEMY_TARGET_Y] - enemy_list[handle][ENEMY_Y]
        dist = sqrt(dx * dx + dy * dy)
        if dist > 1.0 then
            move_x = enemy_list[handle][ENEMY_X] + (dx / dist) * enemy_list[handle][ENEMY_SPEED]
            move_y = enemy_list[handle][ENEMY_Y] + (dy / dist) * enemy_list[handle][ENEMY_SPEED]
            enemy_set_x(handle, move_x)
            enemy_set_y(handle, move_y)
        end if

    elsif state = 1 then  -- Chase
        enemy_list[handle][ENEMY_TARGET_X] = player_x
        enemy_list[handle][ENEMY_TARGET_Y] = player_y
        dx = enemy_list[handle][ENEMY_TARGET_X] - enemy_list[handle][ENEMY_X]
        dy = enemy_list[handle][ENEMY_TARGET_Y] - enemy_list[handle][ENEMY_Y]
        dist = sqrt(dx * dx + dy * dy)
        if dist > 1.0 then
            move_x = enemy_list[handle][ENEMY_X] + (dx / dist) * enemy_list[handle][ENEMY_SPEED]
            move_y = enemy_list[handle][ENEMY_Y] + (dy / dist) * enemy_list[handle][ENEMY_SPEED]
            enemy_set_x(handle, move_x)
            enemy_set_y(handle, move_y)
        end if

        -- ðŸ”« Shooting check
        if dist <= enemy_list[handle][ENEMY_SHOOT_RANGE] then
            if now >= enemy_list[handle][ENEMY_NEXT_SHOT] then
                enemy_shoot(handle)
                enemy_list[handle][ENEMY_NEXT_SHOT] = now + enemy_list[handle][ENEMY_SHOOT_INTERVAL]
            end if
        end if

    elsif state = 2 then  -- Flee
        dx = enemy_list[handle][ENEMY_X] - player_x
        dy = enemy_list[handle][ENEMY_Y] - player_y
        dist = sqrt(dx * dx + dy * dy)
        if dist > 1.0 then
            move_x = enemy_list[handle][ENEMY_X] + (dx / dist) * enemy_list[handle][ENEMY_SPEED] * 1.5
            move_y = enemy_list[handle][ENEMY_Y] + (dy / dist) * enemy_list[handle][ENEMY_SPEED] * 1.5
            enemy_set_x(handle, move_x)
            enemy_set_y(handle, move_y)
        end if
		
		-- ðŸ”« Shooting check
        if dist <= enemy_list[handle][ENEMY_SHOOT_RANGE] then
            if now >= enemy_list[handle][ENEMY_NEXT_SHOT] then
                enemy_shoot(handle)
                enemy_list[handle][ENEMY_NEXT_SHOT] = now + enemy_list[handle][ENEMY_SHOOT_INTERVAL]
            end if
        end if
    end if

    grid_update_position(grid_handle, enemy_list[handle][ENEMY_X], enemy_list[handle][ENEMY_Y])
end procedure