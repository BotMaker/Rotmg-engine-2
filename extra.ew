include misc.e
include get.e

global function is_even(integer test_integer)
	
  return (and_bits(test_integer, 1) = 0)

end function


global function max3(atom a, atom b, atom c)
    atom m
	m = a
    if b > m then
        m = b
    end if
    if c > m then
        m = c
    end if
    return m
end function

global function max(atom a, atom b)
    if a > b then
        return a
    else
        return b
    end if
end function

global function point_distance(atom x1,atom y1 , atom x2, atom y2)
    atom x, y

    x = power(x1 - x2, 2)
    y = power(y1 - y2, 2)

    return sqrt(x + y)
end function


global function point_distance_fast(atom x1, atom y1, atom x2, atom y2)
    atom dx,dy
	dx = x1 - x2
    dy = y1 - y2
    return sqrt(dx*dx + dy*dy)
end function

constant HALFPI    = PI/2

global function atan2(atom y, atom x)
	
  if x > 0 then
		
    return arctan(y/x)
	
  elsif x < 0 then
		
    if y < 0 then
			
      return arctan(y/x) - PI
		
    else
			
      return arctan(y/x) + PI
		
    end if
	
  elsif y > 0 then
		
    return HALFPI
	
  elsif y < 0 then
		
    return -(HALFPI)
	
  else
		
    return 0
	
  end if

end function


global function get_angle_to(atom x, atom y, atom x2, atom y2)
  return (180- atan2(x2 - x ,y2 - y) *180/PI)

end function


global function toRotmgAngle(atom angle)
  return ((angle-90) / (360/PI/2) )

end function


global function degtorad(atom angle)
	  return (angle * (PI/180))
end function


global function radtodeg(atom angle)
	  return angle * (180 / PI)
end function


sequence key_buffer
key_buffer={}


global function abs(atom x)
    if x < 0 then
        x = -x
    end if
    return x
end function--abs


global function remove_line(sequence string, integer line)
sequence temp
integer len
len=length(string)
if line=1 then
  return string[2..len]
elsif line=len then
  return string[1..len-1]
else
  temp=string[1..line-1]
  return temp&string[line+1..len]
end if
end function

global function key_check(integer scancode)
  for i=1 to length(key_buffer) do
    if key_buffer[i]=scancode then
      return 1
    end if
  end for
return 0
end function

global procedure key_add(integer scancode)
integer find1
find1=0
  for i=1 to length(key_buffer) do
    if key_buffer[i]=scancode then
      find1=1
      exit
    end if
  end for
if find1=0 then
  key_buffer=append(key_buffer,scancode)
end if
end procedure

global procedure key_remove(integer scancode)
  for i=1 to length(key_buffer) do
     if key_buffer[i]=scancode then
       key_buffer=remove_line(key_buffer,i)
       exit
     end if
  end for
end procedure

global function real(sequence string)
sequence temp
temp=value(string)
return temp[2]
end function

--global function wrap_between(integer v,integer min, integer max)

--	while v<min do
--		v+=max
--	end while
	
--	while v>max do
--		v-=max
--	end while
	
--	return v
--end function

global function wrap_between(integer v,integer min, integer max)
  return v - (max - min) * floor( v / (max - min))
end function




global procedure usleep(integer v)
	c_proc(Sleep,{v})
end procedure

global function get_tick_count()
  return  c_func(GetTickCount,{})
end function

global atom c_start_time
c_start_time=get_tick_count()

global function current_time()
  return  c_func(GetTickCount,{})-c_start_time
end function